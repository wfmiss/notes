(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{503:function(_,v,t){"use strict";t.r(v);var e=t(20),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"第二章-80x86微处理器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二章-80x86微处理器"}},[_._v("#")]),_._v(" 第二章 80X86微处理器")]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("二、80X86微处理器\n（一）知识范围\n8086/8088CPU的内部结构和外部引线； \n8086/8088CPU的工作方式；\n8086/8088CPU系统总线的形成；\n8086/8088的存储器结构；\n总线操作及时序。\n（二）考核要求\n1.\t掌握8086/8088CPU的功能构成及流水线技术，理解流水线管理规则。\n2.\t掌握 8086/8088CPU寄存器的组成及其应用。\n3.\t理解8086/8088CPU的内存分配，掌握实地址模式下的存储器地址变换方法。\n4.\t掌握8086/8088CPU的引脚构成，理解其引脚复用的特性。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br"),t("span",{staticClass:"line-number"},[_._v("6")]),t("br"),t("span",{staticClass:"line-number"},[_._v("7")]),t("br"),t("span",{staticClass:"line-number"},[_._v("8")]),t("br"),t("span",{staticClass:"line-number"},[_._v("9")]),t("br"),t("span",{staticClass:"line-number"},[_._v("10")]),t("br"),t("span",{staticClass:"line-number"},[_._v("11")]),t("br"),t("span",{staticClass:"line-number"},[_._v("12")]),t("br")])]),t("h2",{attrs:{id:"_1-16位微处理器概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-16位微处理器概述"}},[_._v("#")]),_._v(" 1. 16位微处理器概述")]),_._v(" "),t("p",[_._v("8086和8088 CPU的内部基本相同，但它们的外部性能是有区别的。")]),_._v(" "),t("p",[_._v("8086 是16位数据总线，而8088是8位数据总线，在处理一个16位数据字时，8088需要两步操作而8086只需要一步。")]),_._v(" "),t("p",[_._v("8086和8088 CPU的内部都采用16位字进行操作及存储器寻址，两者的软件完全兼容，程序的执行也完全相同。")]),_._v(" "),t("p",[_._v("然而，由于8088要比8086有较多的"),t("strong",[_._v("外部存取操作")]),_._v("。所以，对相同的程序，它将执行得较慢。这两种微处理器都封装在相同的40脚双列直插组件(DIP)中。")]),_._v(" "),t("h2",{attrs:{id:"_2-8086-8088微型处理器结构-cpu"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-8086-8088微型处理器结构-cpu"}},[_._v("#")]),_._v(" 2. 8086/8088微型处理器结构（CPU）")]),_._v(" "),t("h3",{attrs:{id:"_2-1-8086-cpu内部结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-8086-cpu内部结构"}},[_._v("#")]),_._v(" 2.1 8086 CPU内部结构")]),_._v(" "),t("p",[_._v("8086 CPU从功能上可分两部分，即"),t("strong",[_._v("总线接口部件（BIU）和指令执行部件（EU）")]),_._v("。8086的内部结构如图。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210526181730.png",alt:""}})]),_._v(" "),t("p",[_._v("指令执行部件（EU）主要由算数运逻辑运算单元（ALU）、标志寄存器（FR）、通用寄存器组和EU控制电路4个部件组成，其主要功能就是负责指令执行。将指令译码并利用内部的寄存器和ALU对数据进行所需处理。")]),_._v(" "),t("p",[_._v("总线接口部件（BIU）主要由地址加法器、专用寄存器组、指令队列和总线控制电路4个部件组成，其主要功能是形成访问存储器的物理地址、访问存储器并存取指令暂存到指令队列中等待执行，访问存储器或I/O端口读取操作数来参加EU运算或存放运算结果等。")]),_._v(" "),t("h3",{attrs:{id:"_2-2指令执行部件-eu"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2指令执行部件-eu"}},[_._v("#")]),_._v(" 2.2指令执行部件（EU）")]),_._v(" "),t("p",[t("strong",[_._v("指令执行部件由下列部分组成：")])]),_._v(" "),t("ul",[t("li",[_._v("寄存器：\n"),t("ul",[t("li",[_._v("4个16位通用寄存器，这些寄存器除了具有保存数据和地址作用外，各寄存器还有其特殊用途。\n"),t("ul",[t("li",[_._v("AX（累加器）：一般用来存放参加运算的数据和结果，在乘，除法运算、I/O操作、BCD数运算中有不可替代的作用。")]),_._v(" "),t("li",[_._v("BX（基址寄存器）：除可作为数据寄存器外，还可存放内存的逻辑偏移地址，而AX，CX，DX不能。")]),_._v(" "),t("li",[_._v("CX（数据寄存器）：既可以作为数据寄存器，又可串指令和位移指令中作为计数用。")]),_._v(" "),t("li",[_._v("DX（数据寄存器）：除可作为通用数据寄存器外，还在乘、除法运算、带符号数的扩张指令中有特殊用途。")]),_._v(" "),t("li",[_._v("通用寄存器既可以用来存放16位的数据或地址，也可把它们作为8位寄存器来使用，即把每个16位的通用寄存器分成高8位和低8位。低8位被命名为AL、BL、CL和DL、，高八位被命名为AH、BH、CH和DH。这些寄存器一般存放8位数据。")])])]),_._v(" "),t("li",[_._v("4个16位专用寄存器，主要用来存放存储器或I/O端口的地址。\n"),t("ul",[t("li",[_._v("SI（源变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。")]),_._v(" "),t("li",[_._v("DI（目标变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。")]),_._v(" "),t("li",[_._v("BP（基址指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。")]),_._v(" "),t("li",[_._v("SP（堆栈指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。")])])])])]),_._v(" "),t("li",[_._v("标志寄存器（FR）")]),_._v(" "),t("li",[_._v("算数逻辑部件（ALU）")]),_._v(" "),t("li",[_._v("内部控制逻辑")])]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("8086/8088 的EU有以下特点：")])]),_._v(" "),t("p",[t("strong",[_._v("8个16位通用寄存器：")])]),_._v(" "),t("ul",[t("li",[_._v("数据寄存器（AX、BX、CX、DX）\n"),t("ul",[t("li",[_._v("可用来存放16位的数据地址，又可分为8个8位寄存器(只能存放数据而不能存放地址)，即：")])])])]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("寄存器特有的习惯用法：\nAX ——> AH,AL\tAX:所有I/O指令都通过AX或AL与接口传输信息，中间运算结果也多放于AX中。\nBX ——> BH,BL \tBX:在间接寻址中用于存放基地址。\nCX ——> CH,CL \tCX:可以用作数据寄存器，在字符串操作、循环操作和位移操作时用作计数器，存放计数值。\nDX ——> DH,DL \tDX:在间接寻址的I/O指令中存放I/O端地址；在32位乘除法运算时，存放高16位数。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br")])]),t("hr"),_._v(" "),t("p",[t("strong",[_._v("指针和变址寄存器（SP、BP、SI、DI）：")])]),_._v(" "),t("p",[_._v("4个16位寄存器，主要用来存放操作数的偏移地址（即操作数的段内地址）。")]),_._v(" "),t("ul",[t("li",[_._v("SP（堆栈指针寄存器）：在堆栈操作中存放栈顶的偏移地址。（不能寻址，路标）")]),_._v(" "),t("li",[_._v("BP（基址指针寄存器）：常用于在访问内存时存放内存单元的偏移地址，还用作堆栈区的基地址寄存器。（可以寻址）")])]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("注意BX与BP在应用上的区别：\n\n  - 作为通用寄存器（16位寄存器），二者均可用于存放数据\n  - 作为基址寄存器，用BX表示所寻找的数据在数据段；用BP则表示数据在堆栈段\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br")])]),t("ul",[t("li",[t("p",[_._v("SI（源变址寄存器）：主要用于存放地址，在字符串操作中存放源操作数的偏移地址。")])]),_._v(" "),t("li",[t("p",[_._v("DI（目的变址寄存器）：主要用于存放地址，在字符串操作中存放目的操作数的偏移地址。")])])]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("变址寄存器常用于指令的间接寻址或变址寻址。\n在串操作中变址寄存器内存放的地址在数据传送完成后，具有自动修改的功能。\n例如:传送1字节数据之后地址自动加1，为下次传送做好准备，变址寄存器因此得名。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br")])]),t("hr"),_._v(" "),t("p",[t("strong",[_._v("算数逻辑单元（ALU）及标志寄存器（FR）")])]),_._v(" "),t("ul",[t("li",[_._v("算数逻辑运算单元ALU：\n"),t("ul",[t("li",[_._v("可完成16位或8位的算数逻辑运算，运算结果通过内部总线送到通用寄存器，或者送往BIU的内部寄存器中，等待写入存储器。ALU运算后的结果特征（有无进位，溢出等）置入标志寄存器FLAGS中保存。")])])]),_._v(" "),t("li",[_._v("标志寄存器FLAGS：（FLAGS=FR=PSW）\n"),t("ul",[t("li",[_._v("16位寄存器，用来存放运算结果的特征和控制标志。")])])])]),_._v(" "),t("img",{staticStyle:{zoom:"150%"},attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210526231231.png"}}),_._v(" "),t("p",[_._v("根据功能，8086的标志可以分为两类：")]),_._v(" "),t("ul",[t("li",[_._v("状态标志：6个，用来表示运算结果的特征。包括CF、PF、AF、ZF、SF和OF")]),_._v(" "),t("li",[_._v("控制标志：3个，用来控制CPU的操作。包括IF、DF和TF。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210528001205.jpg",alt:""}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210526232227.png",alt:"表4-1 8086/8088 标志位表"}})]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("内部控制逻辑电路")])]),_._v(" "),t("p",[_._v("主要功能：从指令队列缓冲器中取出指令，对指令进行译码。并产生各种控制信号，控制各种部件的协同工作以完成指令的过程。")]),_._v(" "),t("h3",{attrs:{id:"_2-3总线接口部件-biu"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3总线接口部件-biu"}},[_._v("#")]),_._v(" 2.3总线接口部件（BIU）")]),_._v(" "),t("p",[t("strong",[_._v("功能：")])]),_._v(" "),t("ul",[t("li",[_._v("形成访问存储器的物理地址（实际地址）；")]),_._v(" "),t("li",[_._v("访问存储器取得指令并暂存到指令队列中等待执行；")]),_._v(" "),t("li",[_._v("访问存储器或I/O端口以读取操作参数与EU运算，或存放运算结果等。")]),_._v(" "),t("li",[_._v("逻辑地址形式——"),t("code",[_._v("段地址:偏移地址(有效地址)")])])]),_._v(" "),t("p",[t("strong",[_._v("总线接口部件由下列各部分组成：")])]),_._v(" "),t("ul",[t("li",[_._v("4个段地址寄存器，即:")])]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("CS —— 16位代码段寄存器;\nDS —— 16位数据段寄存器;\nES —— 16位附加段寄存器;\nSS —— 16位堆栈段寄存器。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br")])]),t("ul",[t("li",[_._v("16位指令指针寄存器 IP。")]),_._v(" "),t("li",[_._v("20位地址加法器。")]),_._v(" "),t("li",[_._v("6字节的队列指令。")]),_._v(" "),t("li",[_._v("总线控制逻辑")])]),_._v(" "),t("p",[t("strong",[_._v("8086/8088的 BIU有如下特点：")])]),_._v(" "),t("ul",[t("li",[_._v("8086 的指令队列为6个字节，8088的指令队列为4个字节。不管是8086还是8088，都会在执行指令的同时，从内存中取下一条指令或下几条指令，取来的指令就放在指令列中。这样，一般情况下，CPU执行完一条指令就可以立即执行下一条指令，而不需要像以往的计算机那样，让CPU轮番进行取指令和执行指令的操作，从而提高了CPU的效率。")]),_._v(" "),t("li",[_._v("20位地址加法器专门用来完成由逻辑地址变换成物理地址的功能，实际上是进行一次地址加法，将两个16位的逻辑地址变换为20位的物理地址从而使可寻址的存储空间达到1 MB。")]),_._v(" "),t("li",[_._v("物理地址转换方法：")])]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("物理地址（20）=段地址（高16位）+偏移地址(有效地址，低16位)\n例如：\n段地址为：\t0001 0010 0011 0100\n偏移地址为:\t0000 1010 1111 1011\n物理地址计算：\n\t0001 0010 0011 0100 0000（后补四个0）\n+\t     0000 1010 1111 1011\n-----------------------------\n    0001 0010 1110 0011 1011\n物理地址：0001 0010 1110 0011 1011（20位）\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br"),t("span",{staticClass:"line-number"},[_._v("6")]),t("br"),t("span",{staticClass:"line-number"},[_._v("7")]),t("br"),t("span",{staticClass:"line-number"},[_._v("8")]),t("br"),t("span",{staticClass:"line-number"},[_._v("9")]),t("br"),t("span",{staticClass:"line-number"},[_._v("10")]),t("br")])]),t("p",[_._v("只有寻址的时候用的是物理地址，在内部交换数据时用的是"),t("strong",[_._v("逻辑地址形式")]),_._v("——"),t("code",[_._v("段地址:偏移地址(有效地址)")])]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("**段基址：**表示一个段的起始地址的高16位。")]),_._v(" "),t("p",[t("strong",[_._v("段首地址")]),_._v(" = 段基址 "),t("code",[_._v("*")]),_._v("16")]),_._v(" "),t("p",[_._v("**偏移地址：**表示段内的一个单元距离段开始位置的距离，因此，偏移地址也称为段内地址。")]),_._v(" "),t("p",[_._v("例如：")]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("2345H:1100H\n段基址为（段的起始地址）：2345H\n段内偏移地址为：1100H的存储单元地址。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br")])]),t("hr"),_._v(" "),t("p",[t("strong",[_._v("地址加法器")])]),_._v(" "),t("p",[_._v("功能：完成逻辑地址向物理地址的变换。")]),_._v(" "),t("p",[_._v("物理地址：访问存储器的实际地址，用20位2进制表示。")]),_._v(" "),t("p",[_._v("方法：物理地址=段基址"),t("code",[_._v("*")]),_._v("16(即左移4位)+偏移地址")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("指令指针寄存器IP——16位")])]),_._v(" "),t("p",[_._v("功能：用来存放将要执行的下一条指令在代码中的偏移地址。在程序运行过程中，BIU自动修改IP中的内容，使它始终指向将要执行的下一条命令。")]),_._v(" "),t("p",[_._v("注意：程序不能直接访问IP，但是可以通过某些指令修改IP的内容。例如，执行转移指令时，会将转移的目标地址送入IP中，以实现程序转移。")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("指令队列缓冲器——6字节")])]),_._v(" "),t("p",[_._v("BIU从存储器中读出指令送入6字节（8086是6字节、8088是4字节）的指令队列。一旦指令队列中空出2个字节，BIU将自动进行读取指令的操作以填满指令队列。只要收到EU送来的操作数地址，BIU将立即形成这个操作数的物理地址，完成读/写操作。遇到转移类指令，BIU将指令对列中剩余的指令作废，重新从存储器新的地址单元中取指令并送指令队列。一般情况下应保证指令队列中填满指令，使得EU可以不断地得到等待执行指令。")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("总线控制逻辑")])]),_._v(" "),t("p",[_._v("是将CPU的内部总线与CPU引脚所连接的外部总线相连，是CPU与外部交换信息（数据、地址、状态、控制信息）的必经之路，包括16条数据线、20条地址线和若干条控制信号线。")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("总线接口部件和执行部件并不是同步工作的，它们是按以下流水线技术原则管理：")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("每当8086 的指令队列中有两个空字节，或者8088的指令队列中有一个空字节时，总线接口部件就会自动把指令取到指令队列中。")])]),_._v(" "),t("li",[t("p",[_._v("每当执行部件准备执行一条指令时，它会从总线接口部件的指令队列前部取出指令的代码，然后用几个时钟周期去执行指令。在执行指令的过程中，如果必须访问存储器或者输入/输出设备，那么，执行部件就会请求总线接口部件，进人总线周期，完成访问内存或者输人/输出端口的操作；如果此时总线接口部件正好处于空闲状态，那么，会立即响应执行部件的总线请求。但有时会遇到这样的情况，执行部件请求总线接口部件访问总线时，总线接口部件正在将某个指令字节取到指令队列中，此时总线接口部件将首先完成这个取指令的总线周期，然后再去响应执行部件发出的访问总线的请求。")])]),_._v(" "),t("li",[t("p",[_._v("当指令队列已满，而且执行部件又没有总线访问时，总线接口部件便进人空闲状态。")])]),_._v(" "),t("li",[t("p",[_._v("在执行转移指令、调用指令和返回指令时，下面要执行的指令就不是在程序中紧接着的那条指令了，而总线接口部件往指令队列装入指令时，总是按顺序进行的，这样，指令队列中已经装入的字节就没有用了。遇到这种情况，指令队列中的原有内容被自动消除，总线接口部件会接着往指令队列中装人另一个程序段中的指令。")])])]),_._v(" "),t("h3",{attrs:{id:"_2-4-8086-cpu的寄存器结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-8086-cpu的寄存器结构"}},[_._v("#")]),_._v(" 2.4 8086 CPU的寄存器结构")]),_._v(" "),t("p",[t("strong",[_._v("一、通用寄存器")])]),_._v(" "),t("p",[_._v("微处理器的结构中存在着许多寄存器，其作用是让程序暂存数据和地址。8086 CPU指令执行部件EU中有8个16位通用寄存器，它们分成两组。")]),_._v(" "),t("p",[_._v("一组由AX、BX、CX和DX构成，称为通用数据寄存器。这些通用数据寄存器除了具有保存数据和地址作用外，各寄存器还有其特殊的用途。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("AX (Accumulator Register，累加器): 一般用来存放参加运算的数据和结果，在乘、除法运 算、I/O 操作、BCD数运算中有不可替代的作用。")])]),_._v(" "),t("li",[t("p",[_._v("BX (Base Register，基址寄存器)：除可作为数据寄存器外，还可存放内存的逻辑偏移地址，而AX、CX、DX则不能。")])]),_._v(" "),t("li",[t("p",[_._v("CX (Counter Register ，数据寄存器)：既可作为数据寄存器，又可在串指令和移位指令中作为计数用。")])]),_._v(" "),t("li",[t("p",[_._v("DX (Data Register ，数据寄存器)：除可作为通用数据寄有器外，还在乘、除法运算、带符号数的扩展指令中有特殊用途。")])])]),_._v(" "),t("p",[_._v("通用寄在器既可用来存放16位的数据或地址，也可把它们作为8位寄存器来使用，即把每个16位的通用寄存器分成高8位和低8位。低8位被命名为AL、BL、CL和DL，高8位被命名为 AH、BH、CH和DH。这些寄存器一 般存放8位数据。")]),_._v(" "),t("p",[_._v("另一组为4个16位寄存器，主要用来存放存储器或I/O端口的地址。")]),_._v(" "),t("ul",[t("li",[_._v("SI（源变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。")]),_._v(" "),t("li",[_._v("DI（目标变址寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在数据段寄存器中），也可以存放数据。")]),_._v(" "),t("li",[_._v("BP（基址指针寄存器）：多用于存放内存的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。")]),_._v(" "),t("li",[_._v("SP（堆栈指针寄存器）：多用于存放栈顶的逻辑偏移地址（隐含的逻辑段地址在堆栈段寄存器中），也可以存放数据。")])]),_._v(" "),t("p",[_._v("为了更好地管理存储器，8086CPU把它所对应的存储空间分成几个逻辑段，而存放在上述指针或变址寄存器中的往往是在某逻辑段中寻址的偏移地址。例如，一条ADD指令可以在当前 数据段中指定它的一一个操作数，办法之一就 是把该操作数的偏移量放在一个指示 器或变址寄存器中。当然，这些寄存器也可以存放16位数据。")]),_._v(" "),t("p",[_._v("这些通用寄存器对于一些指令来说，它们具有一致性。 例如，ADD指令可将任意两个8位或 16位通用寄存器的内容相加，结果可存放到这两个寄存器中的任何一个中。 为了缩短指令代码长度，8086 CPU的少数指令把某些通用寄存器作为专用。例如，串操作指令总是用CX寄存器存放串的长度，并在串操作指令执行过程中，CX寄存器专用于计数。这样，所有串操作指令就不必 再在指令中指定CX寄存器，因而缩短了串操作指令的代码长度。如果在指 令中没有明显标出，但指令中又需要使用这些寄存器，通常将其称为“隐含寻址”。隐含寻址实际上是在某类指令中指定某些通用寄存器作为特殊用法。程序设计者在编制程序时需遵循这些规定，将某些特殊数据放在特定的寄存器中，才能正确地执行这些指令。这样也许会给程序设计者带来一些麻烦，但因其采用“隐含”方式，能有效地缩短指令代码的长度。")]),_._v(" "),t("p",[_._v("在8086 CPU中，有些寄存器具有上述隐含性质，即相应的指令中不必给出寄存器名；另有 一些寄存器虽也具有特殊用途， 但不能隐含寻址，指令中使用这些寄存器时，必须给出它们的寄存器名。表2-1给出了这些寄存器的特珠用途和隐含性质。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210530174003.jpg",alt:""}})]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("二、段寄存器")])]),_._v(" "),t("p",[_._v("8086 CPU总线接口部件（BIU）有如下4个16位段寄存器。")]),_._v(" "),t("p",[_._v("CS （代码段寄存器）：存放程序代码段起始地址的高16位。")]),_._v(" "),t("p",[_._v("DS（数据段寄存器）：存放数据段起始地址的高16位。")]),_._v(" "),t("p",[_._v("SS（堆栈段寄存器）：存放堆栈段起始地址的高16位。")]),_._v(" "),t("p",[_._v("ES（扩展段寄存器）：存放扩展数据段起始地址的高16位。")]),_._v(" "),t("p",[t("strong",[_._v("存储器的分段")])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[_._v("\t8086具有1 MB的存储空间，但放在指令指示器和变址寄存器中的地址都只有16位。仅16 位地址不能直接提供1 MB存储器寻址，只能在一个特定的64 KB段的偏移量中寻址。由此，划分地址段并且确定偏移量寻址是在哪段中进行的就变得至关重要了。在8086系统中，1 MB的存储空间可被分成许多逻辑段，每段最长为64 KB，这些逻辑段可在整个1 MB存储空间中浮动。同时，划分的各逻辑段首地址的高16位存放在该段寄存器中，这个高16位地址又称为段基址。 这样，代码段寄存器(CS) 用来存放当前代码段的段基址，数据段寄存器(DS)用来存放当前数据段的段基址，扩展段寄存器(ES) 用来存放扩展段的段基址，堆栈段寄存器(SS)用来存放堆栈段的段基址。\n")])])]),t("p",[_._v("​\t\t将1 MB的存储空间分成若干块，称为 “逻辑段” ，每个逻辑段容量 <= 64 KB,存储空间可分成16个逻辑段（0~15）。在段内寻址人采用传统的16位地址寻址方法。在8086存储空间中，把16字节的存储空间称作一节。要求各个逻辑段从节的整数边界开始，即段首地址低4位应该是 ”0“ ，把首段地址的高16位称为 “段基址” ，存放在段寄存器DS或CS或SS或ES中。")]),_._v(" "),t("p",[_._v("​\t\t允许段在整个存储空间浮动，即段与段之间可以部分重叠、完全重叠、连续排列。在整个存储空间中可以设置若干个逻辑段。对于任何一个物理地址，可以唯一地被包含在一个逻辑段中，也可以包含在多个相互重叠段中，只要有段的地址就可以访问到这个物理逻辑地址所对应的存储空间。")]),_._v(" "),t("p",[_._v("​\t\t用于存放段基址有4个16位段寄存器，代码段寄存器CS，数据段寄存器DS，附加段寄存器ES和堆栈寄存器SS。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("代码段CS：存放程序代码，程序代码超过64 KB时，需要分成几个段存放。CS中存放的是现在正在执行的程序段的段基址。")])]),_._v(" "),t("li",[t("p",[_._v("数据段DS：用于存放当前使用的数据。需要第二个数据段时可以使用附加段。")])]),_._v(" "),t("li",[t("p",[_._v("堆栈段SS：是内存中的一块存储区，用来存放专用数据。如调用子程序是的入口参数，返回地址等，这些数据都按照 “后进先出” 的规则进行存取。SS存放堆栈段的段基址，SP存放当前堆栈栈顶的偏移地址。数据进出堆栈要使用专门的堆栈操作指令，SP的值在执行堆栈操作指令时根据规则自动地进行修改。")])])]),_._v(" "),t("p",[_._v("在编程时，程序和各种不同类型的数据分别存放在不同的逻辑段中，它们的 “段基址” 存放在 “段寄存器” 中，段内的偏移地址存放在指针寄存器或变址寄存器中。")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("三、标志寄存器")])]),_._v(" "),t("p",[_._v("8086的标志可以分为两类：")]),_._v(" "),t("ul",[t("li",[_._v("状态标志：6个，用来表示运算结果的特征。包括CF、PF、AF、ZF、SF和OF")]),_._v(" "),t("li",[_._v("控制标志：3个，用来控制CPU的操作。包括IF、DF和TF。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210528001205.jpg",alt:""}})]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("四、指令指针寄存器")])]),_._v(" "),t("p",[_._v("指令指针寄存器IP，里面放置的是不是指令，而是一个指向下一个将要去获取的指令的内存地址（所以它是一个指针）。")]),_._v(" "),t("h2",{attrs:{id:"_3-8086-cpu引脚的功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-8086-cpu引脚的功能"}},[_._v("#")]),_._v(" 3.8086 CPU引脚的功能")]),_._v(" "),t("p",[_._v("8086 CPU是16位的微处理器，它向外的信号应包含16条数据线，20条地址线，再加上其他一些必要的控制信号。为了减少芯片引脚数量对部分引脚采用了分时复用的方式，构成40条引脚的双列直插式封装。")]),_._v(" "),t("p",[t("strong",[_._v("分时复用：")]),_._v(" 就是在同一根传输线上，在不同时间传不同信息。")]),_._v(" "),t("h3",{attrs:{id:"_1-8086总线周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-8086总线周期"}},[_._v("#")]),_._v(" 1.8086总线周期")]),_._v(" "),t("p",[t("strong",[_._v("时钟周期：")]),_._v(" CPU的一切操作都是在系统主时钟"),t("code",[_._v("CLK")]),_._v("的控制下按节拍有序地进行。"),t("code",[_._v("周期 = 1/频率")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("总线周期：")]),_._v(" CPU通过外部总线对存储器或I/O端口进行一次读/写操作的过程称为总线周期。为完成对存储或I/O端口访问的一次访问，CPU需要先后发出读或者写操作命令，进行数据传输。以上的每一个操作都需要延续一个或几个时钟周期。所以一个总线周期由若干个（一般为4个）时钟周期（T）组成。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210530192204.png",alt:""}})]),_._v(" "),t("ul",[t("li",[t("p",[t("code",[_._v("T1")]),_._v("状态：CPU向多路复用总线上发送地址信息（"),t("code",[_._v("A19~A0")]),_._v("）指出要寻址的内存单元地址或I/O端口地址。这期间CPU还要送出地址锁存信号ALE（正向脉冲），在ALE的下降沿将内存单元地址或I/O端口地址存入地址锁存器。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("T2")]),_._v("状态：CPU从总线上撤销地址，使总线低16位呈现高阻状态，为传输数据作准备。总线高4位（"),t("code",[_._v("A19~A16")]),_._v("）输出总线周期的状态信息，用以表示中断允许状态及正在使用的段寄存器名等。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("T3")]),_._v("状态："),t("code",[_._v("A19~A16")]),_._v("上状态信息不变，总线低16位上出现CPU要写出的数据或准备读入数据。若外设或内存来不及与总线交换数据，以使在"),t("code",[_._v("T4")]),_._v("状态下结束该总线周期，则应通过CPU的"),t("code",[_._v("READY")]),_._v("信号，在"),t("code",[_._v("T3")]),_._v("前沿（下降沿）之前向CPU申请插入等待状态"),t("code",[_._v("TW")]),_._v("。在"),t("code",[_._v("T3")]),_._v("及"),t("code",[_._v("TW")]),_._v("的前沿查询"),t("code",[_._v("READY")]),_._v("线，查到高电平则结束等待状态，进入下一状态。否则继续插入等待状态。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("T4")]),_._v("状态：总线周期结束，若为总线读周期则在"),t("code",[_._v("T4")]),_._v("前沿将数据读入CPU。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("TI")]),_._v("状态：总线空闲周期")])])]),_._v(" "),t("h3",{attrs:{id:"_2-8086-cpu的引脚及功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-8086-cpu的引脚及功能"}},[_._v("#")]),_._v(" 2.8086 CPU的引脚及功能")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/wfmiss/pictures/Principle_and_application_of_microcomputer/20210530230928.jpg",alt:""}})]),_._v(" "),t("p",[_._v("8086/8088 CPU有两种不同所谓工作模式（最小模式和最大模式），8条引脚（24~31）在两种工作模式中具有不同的功能。引脚图括号中是最大模式下被重新定义的控制信号。")]),_._v(" "),t("p",[_._v("引脚信号的传输有以下几种类型：")]),_._v(" "),t("ul",[t("li",[_._v("输出：信号从CPU向外部传送；")]),_._v(" "),t("li",[_._v("输入：信号从外部送入CPU；")]),_._v(" "),t("li",[_._v("双向：信号又时从外部送入CPU，有时从CPU向外部传送；")]),_._v(" "),t("li",[_._v("三态：除了高电平、低电平两种状态之外，CPU内部还可以通过一个大的电阻阻断内外信号的传输，CPU内部的状态与外部相互隔离，称为”悬浮态“。")])]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("引脚信号和功能")])]),_._v(" "),t("ol",[t("li",[t("code",[_._v("GND")]),_._v("（地）和"),t("code",[_._v("VCC")]),_._v("（电源）")]),_._v(" "),t("li",[t("code",[_._v("AD15~AD0")]),_._v("地址/数据复用引脚（双向，三态）：作为复用引脚，在总线周期的"),t("code",[_._v("T1")]),_._v("状态用来输出要访问的存储器或I/O端口地址。"),t("code",[_._v("T2~T3")]),_._v("状态，对读周期来说，处于浮空状态；对写周期来说，则是传输数据。")]),_._v(" "),t("li",[t("code",[_._v("A19/S6~A16/S3")]),_._v("地址/状态复用引脚（输出，三态）：在总线周期的"),t("code",[_._v("T1")]),_._v("状态，用来输出用地址的最高4位，"),t("code",[_._v("A19~A16")]),_._v("与"),t("code",[_._v("AD15~AD0")]),_._v("一起构成访问存储器的20位物理地址。CPU访问I/O端口时，"),t("code",[_._v("A19~A16")]),_._v("保持为“0“。在"),t("code",[_._v("T2")]),_._v("，"),t("code",[_._v("T3")]),_._v("，"),t("code",[_._v("TW")]),_._v("和"),t("code",[_._v("T4")]),_._v("状态时，"),t("code",[_._v("S6~S3")]),_._v("用来输出状态信息。")])]),_._v(" "),t("div",{staticClass:"language-txt line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("其中：\nS6: S6=0表示8086CPU占用系统总线，在T2，T3，TW和T4状态时，8086总是使S6=0。\nS5: 反映标志寄存器的中断允许标志IF的设置情况\n\tIF=1，允许可屏蔽中断，则S5=1\n\tIF=0，禁止可屏蔽中断，则S5=0\nS4，S3: 指明正在使用的段寄存器情况。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br"),t("span",{staticClass:"line-number"},[_._v("3")]),t("br"),t("span",{staticClass:"line-number"},[_._v("4")]),t("br"),t("span",{staticClass:"line-number"},[_._v("5")]),t("br"),t("span",{staticClass:"line-number"},[_._v("6")]),t("br")])]),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[_._v("S4")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("S3")]),_._v(" "),t("th",{staticStyle:{"text-align":"center"}},[_._v("表示意义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("正在使用ES")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("正在使用SS")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("0")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("正在使用CS，或者未在使用任何寄存器")])]),_._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("1")]),_._v(" "),t("td",{staticStyle:{"text-align":"center"}},[_._v("正在使用DS")])])])]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("BHE")]),_._v("/S7 高8位数据总线允许/状态复用引脚（输出，三态，低电平有效）：")])]),_._v(" "),t("ul",[t("li",[_._v("在"),t("code",[_._v("T1")]),_._v("状态，"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("BHE")]),_._v("/S7引脚输出"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("BHE")]),_._v("信号，表示高8位数据总线"),t("code",[_._v("D15~D8")]),_._v("上的数据有效。在"),t("code",[_._v("T2")]),_._v("，"),t("code",[_._v("T3")]),_._v("，"),t("code",[_._v("TW")]),_._v("和"),t("code",[_._v("T4")]),_._v("状态，"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("BHE")]),_._v("/S7输出状态信号S7。不过，在当前芯片（8086，8086-1，8086-2）设计中，S7并未被赋予任何实际意义。")]),_._v(" "),t("li",[_._v("8086 CPU有16根数据线，低8位数据线总是和偶地址的储存器或I/O端口相连接，高8位的数据线与奇地址的存储器或I/O端口相连接。")]),_._v(" "),t("li",[t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("BHE")]),_._v("有效，表示CPU正在使用高8位的数据线对奇地址的存储单元或I/O端口进行访问。它与地址码最低位A0配合起来表示当前总线使用情况。")])]),_._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[t("p",[t("code",[_._v("NMI")]),_._v("非屏蔽中断引脚（输入）：非屏蔽中断信号是一个由低到高的上升沿。这类中断不受中断标志IF的影响，也不能用软件进行屏蔽。每当"),t("code",[_._v("NMI")]),_._v("端进人一个正沿触发信号时，CPU就会在结束当前指令后，进入对应于中断类型号为2的非屏蔽中断处理程序。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("INTR")]),_._v("可屏蔽中断请求信号引脚（输入）：可屏蔽中断请求信号为高电平有效，CPU在执行每条指令的最后一个时钟周期会对"),t("code",[_._v("INTR")]),_._v("信号进行采样，如果CPU中的中断允许标志为1，并且又接收到"),t("code",[_._v("INTR")]),_._v("信号，那么，CPU就会在结束当前指令后，响应中断请求，进人一个中断处理子程序。")])]),_._v(" "),t("li",[t("p",[t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("RD")]),_._v("(read)读信号引脚（输出、三态、低电平有效）：此信号指出将要执行一个对内存或I/O端口的读操作。到底是读取内存单元中的数据还是I/O端口中的数据，这决定于M/"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("IO")]),_._v("信号。在一个执行读操作的总线周期中，"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("RD")]),_._v("信号在"),t("code",[_._v("T2")]),_._v("，"),t("code",[_._v("T3")]),_._v("和"),t("code",[_._v("Tw")]),_._v("状态均为低电平。在系统总线进人“保持响应”期间，"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("RD")]),_._v("引脚被浮置为高阻状态。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("CLK")]),_._v("(clock)时钟引脚 (输入)：8086要求时钟信号的占空比为1/3，即1/3周期为高电平，2/3周期为低电平。CPU的所有操作均是在时钟同步下进行的。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("RESET")]),_._v("(reset)复位信号引脚（输入、高电平有效）：8086/8088 要求复位信号至少维持4个时钟周期的高电平才有效。"),t("mark",[_._v("复位信号来到后，CPU便结束当前操作，对处理器标志寄存器（FR）、"),t("code",[_._v("IP")]),_._v(","),t("code",[_._v("DS")]),_._v(","),t("code",[_._v("SS")]),_._v(","),t("code",[_._v("ES")]),_._v("及指令队列清零，而将"),t("code",[_._v("CS")]),_._v("设置为"),t("code",[_._v("FFFFH")]),_._v("。当复位信号变为低电平时，CPU从"),t("code",[_._v("FFFF0H")]),_._v("开始执行程序。")]),_._v("系统程序一般在该物理地址单元放一条转移指令，转到引导程序的入口。")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("READY")]),_._v("(ready)“准备好”信号引脚（输入）：“准备好”信号实际上是由所访问的存储器或I/O设备发来的响应信号，高电平有效。“准备好”信号有效时，表示内存或I/O设备准备就绪，马上就可进行一次数据传输。CPU在每个总线周期的"),t("code",[_._v("T3")]),_._v("状态开始对READY信号进行采样。如果检测到READY为低电平，则在"),t("code",[_._v("T3")]),_._v("状态之后插入等待状态"),t("code",[_._v("Tw")]),_._v(",在"),t("code",[_._v("Tw")]),_._v("状态，CPU也对"),t("code",[_._v("READY")]),_._v("进行采样，若"),t("code",[_._v("READY")]),_._v("仍为低电平，则会继续插人"),t("code",[_._v("Tw")]),_._v("，所以"),t("code",[_._v("Tw")]),_._v("可以插人一个或多个。直到"),t("code",[_._v("READY")]),_._v("变为高电平后，才进人"),t("code",[_._v("T4")]),_._v("状态，完成数据传送过程，从而结束当前总线周期。")])]),_._v(" "),t("li",[t("p",[t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("TEST")]),_._v("( test)测试信号引脚（输入、低电平有效）：测试信号为低电平有效。"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("TEST")]),_._v("信号是和指令"),t("code",[_._v("WAIT")]),_._v("结合起来使用的，在CPU执行"),t("code",[_._v("WAIT")]),_._v("指令时，CPU处于空转状态进行等待；当8086的"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("TEST")]),_._v("信号有效时，等待状态结束，CPU继续往下执行被暂停的指令。")])]),_._v(" "),t("li",[t("p",[_._v("MN/"),t("span",{staticStyle:{"text-decoration":"overline"}},[_._v("MX")]),_._v("最小/最大模式控制信号引脚（输入）：它是最大模式及最小模式的选择控制端。此引脚固定接为"),t("code",[_._v("+5V")]),_._v("时，CPU处于最小模式；如果接地，则CPU处于最大模式。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);